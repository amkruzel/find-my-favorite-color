{
  "version": 3,
  "sources": ["../../scripts/game.ts", "../../scripts/workers/loadColors.ts"],
  "sourcesContent": ["const MAX_COLORS = 0x1000000\n\nexport type color = number & { __type: color }\ntype index = number & { __type: index }\ntype bit = number & { __type: bit }\nexport type colorsAry = [color, color, ...color[]]\n\nexport interface GameProps {\n    favoriteColorFound: boolean\n    currentIteration: number\n    colorsRemainingCurrentIteration: number\n}\n\nfunction assertColor(value: number): asserts value is color {\n    if (parseInt(`${value}`) !== value || value < 0 || value > 0xffffff) {\n        throw new Error(value + 'is not a color!')\n    }\n}\n\nfunction assertIndex(value: number): asserts value is index {\n    if (parseInt(`${value}`) !== value || value < 0 || value > 0x80000) {\n        throw new Error('Not an index!')\n    }\n}\n\nfunction assertBit(value: number): asserts value is bit {\n    if (parseInt(`${value}`) !== value || value < 0 || value & (value - 1)) {\n        throw new Error('Not a bit!')\n    }\n}\n\nfunction assertColorsAry(ary: number[]): asserts ary is colorsAry {\n    if (\n        !ary.every(elem => {\n            assertColor(elem)\n            return true\n        }) ||\n        ary.length < 2\n    ) {\n        console.log(ary)\n        throw new Error('Not a colorsAry!')\n    }\n}\n\n// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\nexport function shuffle<T>(array: T[]): T[] {\n    let currentIndex = array.length\n\n    // While there remain elements to shuffle...\n    while (currentIndex != 0) {\n        // Pick a remaining element...\n        let randomIndex = Math.floor(Math.random() * currentIndex)\n        currentIndex--\n\n        // And swap it with the current element.\n        ;[array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex],\n        ] as [T, T]\n    }\n\n    return array\n}\n\nexport class Game {\n    eliminatedColors: Uint32Array\n    selectedColors: Uint32Array\n    private _favoriteColorFound: boolean\n    private _currentIteration: number\n    private _colorsRemainingCurrentIteration: number\n    _colors: colorsAry\n\n    // TODO\n    // this should/could be implemented as a Uint32Array, representing a list of colors\n    // for the next iteration\n    private _nextIterationColors: color[]\n\n    private _bgJobInstant: number = 0\n\n    constructor(\n        eliminated?: ArrayBuffer,\n        selected?: ArrayBuffer,\n        colors?: ArrayBuffer,\n        props?: GameProps\n    ) {\n        if (!eliminated || !selected || !colors || !props) {\n            this._init()\n        } else {\n            this._load(eliminated, selected, colors, props)\n        }\n    }\n\n    get color1() {\n        return this._colors[this._colors.length - 1] as color\n    }\n\n    get color2() {\n        return this._colors[this._colors.length - 2] as color\n    }\n\n    get currentIteration() {\n        return this._currentIteration\n    }\n\n    get colorsRemainingCurrentIteration() {\n        return this._colorsRemainingCurrentIteration\n    }\n\n    get favoriteColor(): color | null {\n        return this._favoriteColorFound ? this.color1 : null\n    }\n\n    get properties(): GameProps {\n        return {\n            favoriteColorFound: this.favoriteColor !== null,\n            currentIteration: this.currentIteration,\n            colorsRemainingCurrentIteration:\n                this.colorsRemainingCurrentIteration,\n        }\n    }\n\n    get testingProps(): [color[], color[]] {\n        return [this._colors, this._nextIterationColors]\n    }\n\n    get next1000Colors(): Uint32Array {\n        return new Uint32Array(this._colors.slice(0, 1001))\n    }\n\n    private get _bgKey(): number {\n        this._bgJobInstant = Date.now()\n        return this._bgJobInstant\n    }\n\n    selectColor(num: 1 | 2) {\n        this._updateSelectedColors(num)\n        this._colorsRemainingCurrentIteration -= 2\n        this._checkForNewIteration()\n        this._checkForFavoriteColor()\n    }\n\n    reset() {\n        this._init()\n    }\n\n    shuffleColors() {\n        this._colors.push(this._colors.shift()!)\n        this._colors.push(this._colors.shift()!)\n    }\n\n    isEliminated(color: color) {\n        return this._is(color, 'eliminated')\n    }\n\n    isSelected(color: color) {\n        return this._is(color, 'selected')\n    }\n\n    private _init() {\n        this.eliminatedColors = new Uint32Array(0x80000)\n        this.selectedColors = new Uint32Array(0x80000)\n        this._currentIteration = 1\n        this._colorsRemainingCurrentIteration = MAX_COLORS\n        this._favoriteColorFound = false\n        this._nextIterationColors = []\n\n        this._buildColors()\n    }\n\n    private _load(\n        eliminated: ArrayBuffer,\n        selected: ArrayBuffer,\n        colors: ArrayBuffer,\n        props: GameProps\n    ) {\n        this.eliminatedColors = new Uint32Array(eliminated)\n        this.selectedColors = new Uint32Array(selected)\n        this._currentIteration = props.currentIteration\n        this._colorsRemainingCurrentIteration =\n            props.colorsRemainingCurrentIteration\n        this._favoriteColorFound = props.favoriteColorFound\n\n        const tempColors = Array.from(new Uint32Array(colors))\n        assertColorsAry(tempColors)\n        this._colors = tempColors\n\n        this._loadColors()\n    }\n\n    private _loadColors() {\n        console.log('_loadColorsBg')\n        const worker = new Worker('workers/loadColors.js')\n        const data = {\n            colors: this._colors,\n            eliminatedColors: this.eliminatedColors,\n            selectedColors: this.selectedColors,\n        }\n        worker.postMessage(data)\n        worker.addEventListener('message', msg => {\n            const [colors, nextIterationColors] = msg.data\n\n            assertColorsAry(colors)\n            assertColorsAry(nextIterationColors)\n\n            colors.push(...this._colors)\n            this._colors = colors\n\n            nextIterationColors.push(...this._nextIterationColors)\n            this._nextIterationColors = nextIterationColors\n        })\n    }\n\n    private _buildColors() {\n        this._colors = new Array() as colorsAry\n        this._get1000Colors()\n        this._buildColorsBackground()\n    }\n\n    /**\n     * This method does not validate that the colors have not been eliminated or selected\n     */\n    private _get1000Colors() {\n        for (let i = 0; i < 1000; i++) {\n            // ~~ is identical to Math.floor() but is faster\n            let color = ~~(Math.random() * MAX_COLORS)\n            assertColor(color)\n\n            this._colors.push(color)\n        }\n    }\n\n    protected _buildColorsBackground() {\n        console.log('_buildColorsBg')\n        const worker = new Worker('workers/initColors.js')\n        const key = this._bgKey\n        worker.postMessage([this._colors, key])\n        worker.addEventListener('message', msg => {\n            const [colors, oldKey] = msg.data\n            if (oldKey !== key) {\n                return\n            }\n            console.log(colors)\n\n            assertColorsAry(colors)\n            this._colors.splice(0, 0, ...colors)\n\n            // TODO\n            // need to handle the case where a user resets the game\n            // while the background thread is running\n\n            //colors.push(...this._colors)\n            //this._colors = colors\n        })\n    }\n\n    private _updateSelectedColors(num: 1 | 2): void {\n        const _do = (action: 'select' | 'eliminate', color: color): void => {\n            const [index, bit] = this._split(color)\n            const array =\n                action === 'select' ? 'selectedColors' : 'eliminatedColors'\n\n            assertColor(color)\n            if (action === 'select') {\n                this._nextIterationColors.push(this._colors.pop()!)\n            } else {\n                this._colors.pop()\n            }\n            this[array][index] |= bit\n        }\n\n        const selectAndEliminateColors = (select: color, elim: color): void => {\n            _do('select', select)\n            _do('eliminate', elim)\n        }\n\n        const selectedColor = num === 1 ? this.color1 : this.color2\n        const rejectedColor = num === 1 ? this.color2 : this.color1\n\n        selectAndEliminateColors(selectedColor, rejectedColor)\n    }\n\n    private _split(color: color): [index, bit] {\n        const [index, bit] = [color >> 5, 2 ** (color & 31)]\n        assertIndex(index)\n        assertBit(bit)\n        return [index, bit]\n    }\n\n    private _checkForNewIteration() {\n        if (this.colorsRemainingCurrentIteration !== 0) {\n            return\n        }\n\n        this._colorsRemainingCurrentIteration =\n            MAX_COLORS / 2 ** this.currentIteration\n        this._currentIteration++\n        this.selectedColors = new Uint32Array(0x80000)\n\n        const numColorsRemaining = this._nextIterationColors.length\n\n        if (numColorsRemaining < 1) {\n            throw new Error('Array is empty but should not be')\n        } else if (numColorsRemaining === 1) {\n            this._nextIterationColors.push(this._nextIterationColors[0]!)\n        }\n\n        const ary = shuffle(this._nextIterationColors)\n        assertColorsAry(ary)\n        this._colors = ary\n        this._nextIterationColors = []\n    }\n\n    private _checkForFavoriteColor() {\n        this._favoriteColorFound = this.colorsRemainingCurrentIteration === 1\n    }\n\n    private _is(color: color, testingFor: 'eliminated' | 'selected'): boolean {\n        const [index, bit] = this._split(color)\n\n        const num =\n            testingFor === 'eliminated'\n                ? this.eliminatedColors[index]\n                : this.selectedColors[index]\n\n        if (num === undefined) {\n            return false\n        }\n\n        return !!(num & bit)\n    }\n}\n", "import { shuffle } from 'scripts/game'\n\nconst MAX_COLORS = 0x1000000\n\n/**\n * Takes the current _colors array as input and returns a huge array containing all remaining colors, shuffled\n * @param message\n */\nself.onmessage = message => {\n    console.log('starting from worker thread')\n\n    const { colors, eliminatedColors, selectedColors } = message.data\n\n    const newColors = buildShuffledArray(message.data)\n\n    console.log('completed from worker thread - now returning')\n\n    self.postMessage(newColors)\n}\n\nfunction buildShuffledArray(colors: number[]): number[] {\n    if (colors?.length <= 0) {\n        return []\n    }\n\n    const newColors: number[] = []\n    for (let color = 0; color < MAX_COLORS; color++) {\n        if (color % 100000 == 0) {\n            console.log(color)\n        }\n        if (colors.includes(color)) {\n            continue\n        }\n        newColors.push(color)\n    }\n    return shuffle(newColors)\n}\n"],
  "mappings": ";;;AA6CO,WAAS,QAAW,OAAiB;AACxC,QAAI,eAAe,MAAM;AAGzB,WAAO,gBAAgB,GAAG;AAEtB,UAAI,cAAc,KAAK,MAAM,KAAK,OAAO,IAAI,YAAY;AACzD;AAGC,OAAC,MAAM,YAAY,GAAG,MAAM,WAAW,CAAC,IAAI;AAAA,QACzC,MAAM,WAAW;AAAA,QACjB,MAAM,YAAY;AAAA,MACtB;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;;;AC5DA,MAAM,aAAa;AAMnB,OAAK,YAAY,aAAW;AACxB,YAAQ,IAAI,6BAA6B;AAEzC,UAAM,EAAE,QAAQ,kBAAkB,eAAe,IAAI,QAAQ;AAE7D,UAAM,YAAY,mBAAmB,QAAQ,IAAI;AAEjD,YAAQ,IAAI,8CAA8C;AAE1D,SAAK,YAAY,SAAS;AAAA,EAC9B;AAEA,WAAS,mBAAmB,QAA4B;AACpD,QAAI,QAAQ,UAAU,GAAG;AACrB,aAAO,CAAC;AAAA,IACZ;AAEA,UAAM,YAAsB,CAAC;AAC7B,aAAS,QAAQ,GAAG,QAAQ,YAAY,SAAS;AAC7C,UAAI,QAAQ,OAAU,GAAG;AACrB,gBAAQ,IAAI,KAAK;AAAA,MACrB;AACA,UAAI,OAAO,SAAS,KAAK,GAAG;AACxB;AAAA,MACJ;AACA,gBAAU,KAAK,KAAK;AAAA,IACxB;AACA,WAAO,QAAQ,SAAS;AAAA,EAC5B;",
  "names": []
}
