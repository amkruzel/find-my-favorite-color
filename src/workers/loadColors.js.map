{
  "version": 3,
  "sources": ["../../scripts/colors.ts", "../../scripts/condensedColors.ts", "../../scripts/game.ts", "../../scripts/workers/loadColors.ts"],
  "sourcesContent": ["import { color, colorsAry } from './game'\nimport { CondensedColors } from './condensedColors'\n\nconst MAX_COLORS = 0x1000000\n\nexport function assertColor(value: number): asserts value is color {\n    if (parseInt(`${value}`) !== value || value < 0 || value > 0xffffff) {\n        throw new Error(value + 'is not a color!')\n    }\n}\n\nexport function assertColorsAry(ary: number[]): asserts ary is colorsAry {\n    if (\n        !ary.every(elem => {\n            assertColor(elem)\n            return true\n        }) ||\n        ary.length < 2\n    ) {\n        console.log(ary)\n        throw new Error('Not a colorsAry!')\n    }\n}\n\n// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\nfunction shuffle<T>(array: T[]): T[] {\n    let currentIndex = array.length\n\n    // While there remain elements to shuffle...\n    while (currentIndex != 0) {\n        // Pick a remaining element...\n        let randomIndex = Math.floor(Math.random() * currentIndex)\n        currentIndex--\n\n        // And swap it with the current element.\n        ;[array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex],\n        ] as [T, T]\n    }\n\n    return array\n}\n\nexport interface ColorsLoadData {\n    next1000: ArrayBuffer\n    eliminated: ArrayBuffer\n    selected: ArrayBuffer\n}\n\nclass ColorsAry {\n    static new(): colorsAry {\n        return new Array() as colorsAry\n    }\n\n    static from(ary: ArrayBuffer): colorsAry {\n        const tmp = Array.from(new Uint32Array(ary))\n        assertColorsAry(tmp)\n        return tmp\n    }\n}\n\nfunction assertDefined(val: color | undefined): asserts val is color {\n    if (val === undefined) {\n        throw new Error('Value is undefined!')\n    }\n}\n\nexport class Colors {\n    protected selectedColors: color[]\n    protected ary: colorsAry\n    private static bgKey: number\n\n    constructor() {\n        this.init()\n    }\n\n    get color1(): color {\n        return this.getAndValidateColor(1)\n    }\n\n    get color2(): color {\n        return this.getAndValidateColor(2)\n    }\n\n    private getAndValidateColor(num: 1 | 2): color {\n        const c = this.ary[this.ary.length - num]\n        assertDefined(c)\n        return c\n    }\n\n    get next1000Colors(): Uint32Array {\n        return new Uint32Array(this.ary.slice(0, 1001))\n    }\n\n    shuffle(): void {\n        const c1 = this.ary.shift()\n        const c2 = this.ary.shift()\n\n        assertDefined(c1)\n        assertDefined(c2)\n\n        this.ary.push(c1, c2)\n    }\n\n    /**\n     *\n     * @param num Updates ary, ensuring that there are always >= 2 elements\n     * If this.ary.length == 2 at the beginning of the method, then both elements\n     * will be the same at the end - the selected color\n     * @return the colors in the format `[selected, rejected]`\n     */\n    select(num: 1 | 2): [color, color] {\n        const selectedAndRejectedColors = this.getSelectedAndRejected(num)\n        this.selectColor(selectedAndRejectedColors[0])\n\n        // if there were more than two colors left before making a selection\n        if (this.ary.length > 2) {\n            this.pop2()\n        } else {\n            // else, those were the last two colors and we need to reset\n            this.validateAry()\n\n            if (this.favoriteColorFound()) {\n                this.selectedColors.push(this.selectedColors[0]!)\n            }\n\n            this.reset(shuffle(this.selectedColors))\n            this.selectedColors = []\n        }\n\n        return selectedAndRejectedColors\n    }\n\n    private getSelectedAndRejected(num: 1 | 2): [color, color] {\n        const selectedColor = num === 1 ? this.color1 : this.color2\n        const rejectedColor = num === 1 ? this.color2 : this.color1\n        return [selectedColor, rejectedColor]\n    }\n\n    private selectColor(color: color): void {\n        this.selectedColors.push(color)\n    }\n\n    private validateAry(): void {\n        if (this.ary.length !== 2) {\n            throw new Error('Array is the incorrect length')\n        }\n    }\n\n    private favoriteColorFound(): boolean {\n        return this.selectedColors.length === 1\n    }\n\n    static load(data: ColorsLoadData): Colors {\n        const c = new Colors()\n        c.load(data)\n        return c\n    }\n\n    private reset(newAry: color[]): void {\n        assertColorsAry(newAry)\n        this.ary = newAry\n    }\n\n    private get reloadBgKey(): number {\n        Colors.bgKey = Date.now()\n        return Colors.bgKey\n    }\n\n    private pop2(): void {\n        this.ary.splice(this.ary.length - 2, 2)\n    }\n\n    private load(data: ColorsLoadData) {\n        // first 1000\n        this.ary = ColorsAry.from(data.next1000)\n\n        // background\n        this.loadBg({ eliminated: data.eliminated, selected: data.selected })\n    }\n\n    private loadBg(data: { eliminated: ArrayBuffer; selected: ArrayBuffer }) {\n        console.log('_buildColorsBg')\n        const worker = new Worker('workers/loadColors.js')\n        worker.postMessage([this.ary, data, this.reloadBgKey])\n        worker.addEventListener('message', msg => {\n            const [[colors, selectedColors], oldKey] = msg.data\n            if (oldKey !== Colors.bgKey) {\n                return\n            }\n            console.log(colors)\n\n            assertColorsAry(colors)\n            this.ary.splice(0, 0, ...colors)\n\n            if (selectedColors.length !== 0) {\n                this.selectedColors.splice(0, 0, ...selectedColors)\n            }\n        })\n    }\n\n    private init() {\n        this.ary = ColorsAry.new()\n        this.selectedColors = Array()\n        this.first1000()\n        this.background()\n    }\n\n    private first1000(): void {\n        for (let i = 0; i < 1000; i++) {\n            let color: number\n\n            do {\n                // ~~ is identical to Math.floor() but is faster\n                color = ~~(Math.random() * MAX_COLORS)\n                assertColor(color)\n            } while (this.ary.includes(color))\n\n            this.ary.push(color)\n        }\n        assertColorsAry(this.ary)\n    }\n\n    protected background(): void {\n        console.log('_buildColorsBg')\n        const worker = new Worker('workers/initColors.js')\n        worker.postMessage([this.ary, this.reloadBgKey])\n        worker.addEventListener('message', msg => {\n            const [colors, oldKey] = msg.data\n            if (oldKey !== Colors.bgKey) {\n                return\n            }\n            console.log(colors)\n\n            assertColorsAry(colors)\n            this.ary.splice(0, 0, ...colors)\n        })\n    }\n}\n", "import type { color } from './game'\n\ntype index = number & { __type: index }\ntype bit = number & { __type: bit }\n\nfunction assertIndex(value: number): asserts value is index {\n    if (parseInt(`${value}`) !== value || value < 0 || value >= 0x80000) {\n        throw new Error('Not an index!')\n    }\n}\n\nfunction assertBit(value: number): asserts value is bit {\n    if (parseInt(`${value}`) !== value || value < 0 || value & (value - 1)) {\n        throw new Error('Not a bit!')\n    }\n}\n\n/**\n * This class represents a Uint32Array of length 0x80000\n * each bit in each 32 bit number can be used as a flag,\n * such as checking if a color is eliminated or not\n */\nexport class CondensedColors {\n    protected ary: Uint32Array\n\n    constructor(vals?: ArrayBuffer) {\n        this.init(vals)\n    }\n\n    get blob(): Blob {\n        return new Blob([this.ary])\n    }\n\n    has(val: color): boolean {\n        const [index, bit] = this.split(val)\n        const num = this.get(index)\n        return !!(num & bit)\n    }\n\n    add(val: color): void {\n        const [index, bit] = this.split(val)\n        this.ary[index] |= bit\n    }\n\n    reset(): void {\n        this.init()\n    }\n\n    private split(val: color): [index, bit] {\n        const [index, bit] = [val >> 5, 2 ** (val & 31)]\n        assertIndex(index)\n        assertBit(bit)\n        return [index, bit]\n    }\n\n    private get(val: index): number {\n        const num = this.ary[val]\n\n        if (num === undefined) {\n            throw new Error('Value is undefined but should not be')\n        }\n\n        return num\n    }\n\n    private init(vals?: ArrayBuffer) {\n        if (vals) {\n            this.ary = new Uint32Array(vals)\n        } else {\n            this.ary = new Uint32Array(0x80000)\n        }\n    }\n}\n", "import { CondensedColors } from './condensedColors'\nimport { Colors, ColorsLoadData } from './colors'\n\nexport const MAX_COLORS = 0x1000000\n\nexport type color = number & { __type: color }\nexport type colorsAry = [color, color, ...color[]]\n\nexport interface GameProps {\n    favoriteColorFound: boolean\n    currentIteration: number\n    colorsRemainingCurrentIteration: number\n}\n\n// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\nexport function shuffle<T>(array: T[]): T[] {\n    let currentIndex = array.length\n\n    // While there remain elements to shuffle...\n    while (currentIndex != 0) {\n        // Pick a remaining element...\n        let randomIndex = Math.floor(Math.random() * currentIndex)\n        currentIndex--\n\n        // And swap it with the current element.\n        ;[array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex],\n        ] as [T, T]\n    }\n\n    return array\n}\n\nexport class Game {\n    eliminatedColors: CondensedColors\n    selectedColors: CondensedColors\n    private _favoriteColorFound: boolean\n    private _currentIteration: number\n    private _colorsRemainingCurrentIteration: number\n    _colors: Colors\n\n    private _bgJobInstant: number = 0\n\n    constructor(\n        eliminated?: ArrayBuffer,\n        selected?: ArrayBuffer,\n        colors?: ArrayBuffer,\n        props?: GameProps\n    ) {\n        if (!eliminated || !selected || !colors || !props) {\n            this._init()\n        } else {\n            this._load(eliminated, selected, colors, props)\n        }\n    }\n\n    get color1() {\n        return this._colors.color1\n    }\n\n    get color2() {\n        return this._colors.color2\n    }\n\n    get currentIteration() {\n        return this._currentIteration\n    }\n\n    get colorsRemainingCurrentIteration() {\n        return this._colorsRemainingCurrentIteration\n    }\n\n    get favoriteColor(): color | null {\n        return this._favoriteColorFound ? this.color1 : null\n    }\n\n    get properties(): GameProps {\n        return {\n            favoriteColorFound: this.favoriteColor !== null,\n            currentIteration: this.currentIteration,\n            colorsRemainingCurrentIteration:\n                this.colorsRemainingCurrentIteration,\n        }\n    }\n\n    get next1000Colors(): Uint32Array {\n        return this._colors.next1000Colors\n    }\n\n    private get _reloadBgKey(): number {\n        this._bgJobInstant = Date.now()\n        return this._getBgKey\n    }\n\n    private get _getBgKey(): number {\n        return this._bgJobInstant\n    }\n\n    selectColor(num: 1 | 2) {\n        this._select(num)\n        this._colorsRemainingCurrentIteration -= 2\n        this._checkForNewIteration()\n        this._checkForFavoriteColor()\n    }\n\n    reset() {\n        this._init()\n    }\n\n    shuffleColors() {\n        this._colors.shuffle()\n    }\n\n    isEliminated(color: color) {\n        return this.eliminatedColors.has(color)\n    }\n\n    isSelected(color: color) {\n        return this.selectedColors.has(color)\n    }\n\n    protected _init() {\n        this.eliminatedColors = new CondensedColors()\n        this.selectedColors = new CondensedColors()\n        this._currentIteration = 1\n        this._colorsRemainingCurrentIteration = MAX_COLORS\n        this._favoriteColorFound = false\n\n        this._buildColors()\n    }\n\n    private _load(\n        eliminated: ArrayBuffer,\n        selected: ArrayBuffer,\n        colors: ArrayBuffer,\n        props: GameProps\n    ) {\n        this.eliminatedColors = new CondensedColors(eliminated)\n        this.selectedColors = new CondensedColors(selected)\n        this._currentIteration = props.currentIteration\n        this._colorsRemainingCurrentIteration =\n            props.colorsRemainingCurrentIteration\n        this._favoriteColorFound = props.favoriteColorFound\n\n        const data: ColorsLoadData = {\n            next1000: colors,\n            eliminated,\n            selected,\n        }\n\n        this._loadColors(data)\n    }\n\n    private _loadColors(data: ColorsLoadData) {\n        this._colors = Colors.load(data)\n    }\n\n    /**\n     * The primary purpose of this method is to allow for easier testing.\n     * This method is overridded in the test class so that a worker thread is\n     * not used.\n     */\n    protected _buildColors() {\n        this._colors = new Colors()\n    }\n\n    private _select(num: 1 | 2): void {\n        const [selected, rejected] = this._colors.select(num)\n        this.selectedColors.add(selected)\n        this.eliminatedColors.add(rejected)\n    }\n\n    private _checkForNewIteration() {\n        if (this.colorsRemainingCurrentIteration !== 0) {\n            return\n        }\n\n        this._colorsRemainingCurrentIteration =\n            MAX_COLORS / 2 ** this.currentIteration\n        this._currentIteration++\n        this.selectedColors.reset()\n    }\n\n    private _checkForFavoriteColor() {\n        this._favoriteColorFound = this.colorsRemainingCurrentIteration === 1\n    }\n}\n", "import { assertColor, assertColorsAry } from 'scripts/colors'\nimport { CondensedColors } from 'scripts/condensedColors'\nimport { colorsAry, shuffle, color } from 'scripts/game'\n\nconst MAX_COLORS = 0x1000000\n\n/**\n * Takes the current _colors array as input and returns a huge array containing all remaining colors, shuffled\n * @param message\n */\nself.onmessage = message => {\n    console.log('starting from worker thread')\n    console.log(message.data)\n\n    const [colors, arrays, key] = message.data\n\n    const eliminated = new CondensedColors(arrays.eliminated)\n    const selected = new CondensedColors(arrays.selected)\n\n    const [colorsToAdd, nextIterColors] = doWork(colors, {\n        eliminated,\n        selected,\n    })\n\n    assertColorsAry(colorsToAdd)\n    sendIncrementally(colorsToAdd, nextIterColors, key)\n\n    console.log('completed from worker thread - now returning')\n}\n\nfunction doWork(\n    colors: colorsAry,\n    arrays: {\n        eliminated: CondensedColors\n        selected: CondensedColors\n    }\n): [color[], color[]] {\n    // go through all numbers\n    // - if a number is included in colors, skip it\n    // - if a number is included in eliminatedColors, skip it\n    // - if a color is included in selectedColors, add it to nextIterColors\n    const newColors = []\n    const nextIterColors = []\n\n    for (let color = 0; color < MAX_COLORS; color++) {\n        assertColor(color)\n        const isEliminated = arrays.eliminated.has(color)\n        const isSelected = arrays.selected.has(color)\n        const alreadyIncluded = colors.includes(color)\n\n        if (isSelected) {\n            nextIterColors.push(color)\n            continue\n        }\n\n        if (isEliminated || alreadyIncluded) {\n            continue\n        }\n\n        newColors.push(color)\n    }\n\n    return [shuffle(newColors), shuffle(nextIterColors)]\n}\n\nfunction sendIncrementally(\n    colors: color[],\n    nextIterColors: color[],\n    key: number\n): void {\n    const HUNDRED_THOU = 100000\n    for (let i = 0; i < 170; i++) {\n        const min = i * HUNDRED_THOU\n        const max = min + HUNDRED_THOU\n\n        if (min >= MAX_COLORS) {\n            break\n        }\n\n        const colorsSubset = colors.slice(min, max)\n        const nextIterSubset = nextIterColors.slice(min, max)\n\n        console.log(`sending elements ${min} through ${max}`)\n        self.postMessage([[colorsSubset, nextIterSubset], key])\n    }\n}\n"],
  "mappings": "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",
  "names": ["color"]
}
