{
  "version": 3,
  "sources": ["../../scripts/game.ts", "../../scripts/workers/initColors.ts"],
  "sourcesContent": ["import { CondensedColors } from './condensedColors'\nimport { Colors, ColorsLoadData } from './colors'\n\nexport const MAX_COLORS = 0x1000000\n\nexport type color = number & { __type: color }\nexport type colorsAry = [color, color, ...color[]]\n\nexport interface GameProps {\n    favoriteColorFound: boolean\n    currentIteration: number\n    colorsRemainingCurrentIteration: number\n}\n\n// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\nexport function shuffle<T>(array: T[]): T[] {\n    let currentIndex = array.length\n\n    // While there remain elements to shuffle...\n    while (currentIndex != 0) {\n        // Pick a remaining element...\n        let randomIndex = Math.floor(Math.random() * currentIndex)\n        currentIndex--\n\n        // And swap it with the current element.\n        ;[array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex],\n        ] as [T, T]\n    }\n\n    return array\n}\n\nexport class Game {\n    eliminatedColors: CondensedColors\n    selectedColors: CondensedColors\n    private _favoriteColorFound: boolean\n    private _currentIteration: number\n    private _colorsRemainingCurrentIteration: number\n    _colors: Colors\n\n    private _bgJobInstant: number = 0\n\n    constructor(\n        eliminated?: ArrayBuffer,\n        selected?: ArrayBuffer,\n        colors?: ArrayBuffer,\n        props?: GameProps\n    ) {\n        if (!eliminated || !selected || !colors || !props) {\n            this._init()\n        } else {\n            this._load(eliminated, selected, colors, props)\n        }\n    }\n\n    get color1() {\n        return this._colors.color1\n    }\n\n    get color2() {\n        return this._colors.color2\n    }\n\n    get currentIteration() {\n        return this._currentIteration\n    }\n\n    get colorsRemainingCurrentIteration() {\n        return this._colorsRemainingCurrentIteration\n    }\n\n    get favoriteColor(): color | null {\n        return this._favoriteColorFound ? this.color1 : null\n    }\n\n    get properties(): GameProps {\n        return {\n            favoriteColorFound: this.favoriteColor !== null,\n            currentIteration: this.currentIteration,\n            colorsRemainingCurrentIteration:\n                this.colorsRemainingCurrentIteration,\n        }\n    }\n\n    get next1000Colors(): Uint32Array {\n        return this._colors.next1000Colors\n    }\n\n    private get _reloadBgKey(): number {\n        this._bgJobInstant = Date.now()\n        return this._getBgKey\n    }\n\n    private get _getBgKey(): number {\n        return this._bgJobInstant\n    }\n\n    selectColor(num: 1 | 2) {\n        this._select(num)\n        this._colorsRemainingCurrentIteration -= 2\n        this._checkForNewIteration()\n        this._checkForFavoriteColor()\n    }\n\n    reset() {\n        this._init()\n    }\n\n    shuffleColors() {\n        this._colors.shuffle()\n    }\n\n    isEliminated(color: color) {\n        return this.eliminatedColors.has(color)\n    }\n\n    isSelected(color: color) {\n        return this.selectedColors.has(color)\n    }\n\n    protected _init() {\n        this.eliminatedColors = new CondensedColors()\n        this.selectedColors = new CondensedColors()\n        this._currentIteration = 1\n        this._colorsRemainingCurrentIteration = MAX_COLORS\n        this._favoriteColorFound = false\n\n        this._buildColors()\n    }\n\n    private _load(\n        eliminated: ArrayBuffer,\n        selected: ArrayBuffer,\n        colors: ArrayBuffer,\n        props: GameProps\n    ) {\n        this.eliminatedColors = new CondensedColors(eliminated)\n        this.selectedColors = new CondensedColors(selected)\n        this._currentIteration = props.currentIteration\n        this._colorsRemainingCurrentIteration =\n            props.colorsRemainingCurrentIteration\n        this._favoriteColorFound = props.favoriteColorFound\n\n        const data: ColorsLoadData = {\n            next1000: colors,\n            eliminated,\n            selected,\n        }\n\n        this._loadColors(data)\n    }\n\n    private _loadColors(data: ColorsLoadData) {\n        this._colors = Colors.load(data)\n    }\n\n    /**\n     * The primary purpose of this method is to allow for easier testing.\n     * This method is overridded in the test class so that a worker thread is\n     * not used.\n     */\n    protected _buildColors() {\n        this._colors = new Colors()\n    }\n\n    private _select(num: 1 | 2): void {\n        const [selected, rejected] = this._colors.select(num)\n        this.selectedColors.add(selected)\n        this.eliminatedColors.add(rejected)\n    }\n\n    private _checkForNewIteration() {\n        if (this.colorsRemainingCurrentIteration !== 0) {\n            return\n        }\n\n        this._colorsRemainingCurrentIteration =\n            MAX_COLORS / 2 ** this.currentIteration\n        this._currentIteration++\n        this.selectedColors.reset()\n    }\n\n    private _checkForFavoriteColor() {\n        this._favoriteColorFound = this.colorsRemainingCurrentIteration === 1\n    }\n}\n", "import { colorsAry, shuffle } from 'scripts/game'\n\nconst MAX_COLORS = 0x1000000\n\n/**\n * Takes the current _colors array as input and returns a huge array containing all remaining colors, shuffled\n * @param message\n */\nself.onmessage = message => {\n    console.log('starting from worker thread')\n\n    const [ary, key] = message.data\n    buildArrayIncrementally(ary, key)\n\n    console.log('completed from worker thread - now returning')\n}\n\nfunction fullShuffledArray(origColors: number[]): number[] {\n    const colors: number[] = []\n    for (let i = 0; i < MAX_COLORS; i++) {\n        if (origColors.includes(i)) {\n            continue\n        }\n        colors.push(i)\n    }\n\n    return shuffle(colors)\n}\n\nfunction buildArrayIncrementally(colors: number[], key: number): void {\n    const HUNDRED_THOU = 100000\n    const allColors = fullShuffledArray(colors)\n    for (let i = 0; i < 170; i++) {\n        const min = i * HUNDRED_THOU\n        const max = min + HUNDRED_THOU\n\n        if (min >= MAX_COLORS) {\n            break\n        }\n\n        const subset = allColors.slice(min, max)\n\n        console.log(`sending elements ${min} through ${max}`)\n        self.postMessage([subset, key])\n    }\n}\n"],
  "mappings": ";;;AAeO,WAAS,QAAW,OAAiB;AACxC,QAAI,eAAe,MAAM;AAGzB,WAAO,gBAAgB,GAAG;AAEtB,UAAI,cAAc,KAAK,MAAM,KAAK,OAAO,IAAI,YAAY;AACzD;AAGC,OAAC,MAAM,YAAY,GAAG,MAAM,WAAW,CAAC,IAAI;AAAA,QACzC,MAAM,WAAW;AAAA,QACjB,MAAM,YAAY;AAAA,MACtB;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;;;AC9BA,MAAM,aAAa;AAMnB,OAAK,YAAY,aAAW;AACxB,YAAQ,IAAI,6BAA6B;AAEzC,UAAM,CAAC,KAAK,GAAG,IAAI,QAAQ;AAC3B,4BAAwB,KAAK,GAAG;AAEhC,YAAQ,IAAI,8CAA8C;AAAA,EAC9D;AAEA,WAAS,kBAAkB,YAAgC;AACvD,UAAM,SAAmB,CAAC;AAC1B,aAAS,IAAI,GAAG,IAAI,YAAY,KAAK;AACjC,UAAI,WAAW,SAAS,CAAC,GAAG;AACxB;AAAA,MACJ;AACA,aAAO,KAAK,CAAC;AAAA,IACjB;AAEA,WAAO,QAAQ,MAAM;AAAA,EACzB;AAEA,WAAS,wBAAwB,QAAkB,KAAmB;AAClE,UAAM,eAAe;AACrB,UAAM,YAAY,kBAAkB,MAAM;AAC1C,aAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC1B,YAAM,MAAM,IAAI;AAChB,YAAM,MAAM,MAAM;AAElB,UAAI,OAAO,YAAY;AACnB;AAAA,MACJ;AAEA,YAAM,SAAS,UAAU,MAAM,KAAK,GAAG;AAEvC,cAAQ,IAAI,oBAAoB,GAAG,YAAY,GAAG,EAAE;AACpD,WAAK,YAAY,CAAC,QAAQ,GAAG,CAAC;AAAA,IAClC;AAAA,EACJ;",
  "names": []
}
