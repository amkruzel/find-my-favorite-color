{
  "version": 3,
  "sources": ["../scripts/game.ts", "../scripts/_game.ts", "game.test.ts", "tests.ts"],
  "sourcesContent": ["export interface Game {\n    eliminatedColors: Uint32Array\n    selectedColors: Uint32Array\n    color1: color\n    color2: color\n    favoriteColor?: color\n    currentIteration: number\n    colorsRemainingCurrentIteration: number\n    _colors: color[]\n    _nextIterationColors: color[]\n}\n\nexport type color = number & { __type: color }\ntype index = number & { __type: index }\ntype bit = number & { __type: bit }\n\nfunction assertColor(value: number): asserts value is color {\n    if (parseInt(`${value}`) !== value || value < 0 || value > 0xffffff) {\n        throw new Error('Not a color!')\n    }\n}\n\nfunction assertIndex(value: number): asserts value is index {\n    if (parseInt(`${value}`) !== value || value < 0 || value > 0x80000) {\n        throw new Error('Not an index!')\n    }\n}\n\nfunction assertBit(value: number): asserts value is bit {\n    if (parseInt(`${value}`) !== value || value < 0 || value & (value - 1)) {\n        throw new Error('Not a bit!')\n    }\n}\n\nexport function createGame(): Game {\n    const _colors = _getAvailableColors()\n    const [color1, color2] = _getTwoUniqueColors(_colors)\n\n    const game: Game = {\n        eliminatedColors: new Uint32Array(0x80000),\n        selectedColors: new Uint32Array(0x80000),\n        currentIteration: 1,\n        colorsRemainingCurrentIteration: 0x1000000,\n        color1,\n        color2,\n        _colors,\n        _nextIterationColors: [],\n    }\n\n    return game\n}\n\nexport function selectColor(game: Game, num: 1 | 2): void {\n    _updateSelectedColors(game, num)\n    game.colorsRemainingCurrentIteration -= 2\n    _checkForNewIteration(game)\n    _checkForFavoriteColor(game, num)\n    pickTwoColors(game)\n}\n\nexport function pickTwoColors(game: Game): void {\n    if (game._colors.length < 2) {\n        return\n    }\n\n    game.color1 = game._colors.pop()!\n    game.color2 = game._colors.pop()!\n}\n\nexport function reset(game: Game) {\n    const _colors = _getAvailableColors()\n    const [color1, color2] = _getTwoUniqueColors(_colors)\n\n    game.eliminatedColors = new Uint32Array(0x80000)\n    game.selectedColors = new Uint32Array(0x80000)\n    game.currentIteration = 1\n    game.colorsRemainingCurrentIteration = 0x1000000\n    game.color1 = color1\n    game.color2 = color2\n    game._colors = _colors\n}\n\nexport function shuffleColors(game: Game): void {\n    game._colors.push(game.color1)\n    game._colors.push(game.color2)\n    shuffle(game._colors)\n    pickTwoColors(game)\n}\n\nexport function isEliminated(game: Game, color: color): boolean {\n    return _is('eliminated', game, color)\n}\n\nexport function isSelected(game: Game, color: color): boolean {\n    return _is('selected', game, color)\n}\n\nfunction _is(\n    testingFor: 'eliminated' | 'selected',\n    game: Game,\n    color: number\n): boolean {\n    const [index, bit] = _split(color)\n\n    let num: number | undefined\n    if (testingFor === 'eliminated') {\n        num = game.eliminatedColors[index]\n    } else {\n        num = game.selectedColors[index]\n    }\n\n    if (num === undefined) {\n        return false\n    }\n\n    return !!(num & bit)\n}\n\nexport function _split(color: number): [index, bit] {\n    const [index, bit] = [color >> 5, 2 ** (color & 31)]\n    assertIndex(index)\n    assertBit(bit)\n    return [index, bit]\n}\n\nfunction _do(action: 'select' | 'eliminate', game: Game, color: number): void {\n    const [index, bit] = _split(color)\n    const array = action === 'select' ? 'selectedColors' : 'eliminatedColors'\n\n    assertColor(color)\n\n    game._nextIterationColors.push(color)\n\n    game[array][index] |= bit\n}\n\nfunction _getTwoUniqueColors(colors?: color[]): [color, color] {\n    if (colors) {\n        const color1 = colors.pop()!\n        const color2 = colors.pop()!\n\n        return [color1, color2]\n    }\n\n    const color1 = Math.floor(Math.random() * 0x1000000)\n    let color2 = Math.floor(Math.random() * 0x1000000)\n\n    while (color2 == color1) {\n        color2 = Math.floor(Math.random() * 0x1000000)\n    }\n\n    assertColor(color1)\n    assertColor(color2)\n\n    return [color1, color2]\n}\n\nfunction _updateSelectedColors(game: Game, num: 1 | 2) {\n    const selectedColor = num === 1 ? game.color1 : game.color2\n    const rejectedColor = num === 1 ? game.color2 : game.color1\n\n    _do('select', game, selectedColor)\n    _do('eliminate', game, rejectedColor)\n}\n\nfunction _checkForNewIteration(game: Game): void {\n    if (game.colorsRemainingCurrentIteration !== 0) {\n        return\n    }\n\n    game.colorsRemainingCurrentIteration =\n        0x1000000 / 2 ** game.currentIteration\n    game.currentIteration++\n    game.selectedColors = new Uint32Array(0x80000)\n    game._colors = shuffle(game._nextIterationColors)\n    game._nextIterationColors = []\n}\n\nfunction _checkForFavoriteColor(game: Game, num: 1 | 2): void {\n    if (game.colorsRemainingCurrentIteration !== 1) {\n        return\n    }\n\n    game.favoriteColor = num === 1 ? game.color1 : game.color2\n    game.color2 = game.color1\n}\n\nexport function _getAvailableColors(): color[] {\n    const availColors: color[] = []\n\n    for (let i = 0; i < 0x1000000; i++) {\n        availColors.push(i as color)\n    }\n\n    return shuffle(availColors)\n}\n\nfunction shuffle<T>(array: T[]): T[] {\n    let currentIndex = array.length\n\n    // While there remain elements to shuffle...\n    while (currentIndex != 0) {\n        // Pick a remaining element...\n        let randomIndex = Math.floor(Math.random() * currentIndex)\n        currentIndex--\n\n        // And swap it with the current element.\n        ;[array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex],\n        ] as [T, T]\n    }\n\n    return array\n}\n", "const MAX_COLORS = 0x1000000\n\nexport type color = number & { __type: color }\ntype index = number & { __type: index }\ntype bit = number & { __type: bit }\ntype colorsAry = [color, color, ...color[]]\n\nfunction assertColor(value: number): asserts value is color {\n    if (parseInt(`${value}`) !== value || value < 0 || value > 0xffffff) {\n        throw new Error('Not a color!')\n    }\n}\n\nfunction assertIndex(value: number): asserts value is index {\n    if (parseInt(`${value}`) !== value || value < 0 || value > 0x80000) {\n        throw new Error('Not an index!')\n    }\n}\n\nfunction assertBit(value: number): asserts value is bit {\n    if (parseInt(`${value}`) !== value || value < 0 || value & (value - 1)) {\n        throw new Error('Not a bit!')\n    }\n}\n\nfunction shuffle<T>(array: T[]): T[] {\n    let currentIndex = array.length\n\n    // While there remain elements to shuffle...\n    while (currentIndex != 0) {\n        // Pick a remaining element...\n        let randomIndex = Math.floor(Math.random() * currentIndex)\n        currentIndex--\n\n        // And swap it with the current element.\n        ;[array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex],\n        ] as [T, T]\n    }\n\n    return array\n}\n\nexport class _Game {\n    eliminatedColors: Uint32Array\n    selectedColors: Uint32Array\n    private _favoriteColorFound: boolean\n    private _currentIteration: number\n    private _colorsRemainingCurrentIteration: number\n    private _colors: colorsAry\n    private _nextIterationColors: color[]\n\n    constructor() {\n        this._init()\n    }\n\n    public get color1() {\n        return this._colors[this._colors.length - 1] as color\n    }\n\n    public get color2() {\n        return this._colors[this._colors.length - 2] as color\n    }\n\n    public get currentIteration() {\n        return this._currentIteration\n    }\n\n    public get colorsRemainingCurrentIteration() {\n        return this._colorsRemainingCurrentIteration\n    }\n\n    public get favoriteColor(): color | null {\n        return this._favoriteColorFound ? this.color1 : null\n    }\n\n    selectColor(num: 1 | 2) {\n        this._updateSelectedColors(num)\n        this._colorsRemainingCurrentIteration -= 2\n        this._checkForNewIteration()\n        this._checkForFavoriteColor()\n    }\n\n    reset() {\n        this._init()\n    }\n\n    shuffleColors() {\n        shuffle(this._colors)\n    }\n\n    isEliminated(color: color) {\n        return this._is(color, 'eliminated')\n    }\n\n    isSelected(color: color) {\n        return this._is(color, 'selected')\n    }\n\n    private _init() {\n        this.eliminatedColors = new Uint32Array(0x80000)\n        this.selectedColors = new Uint32Array(0x80000)\n        this._currentIteration = 1\n        this._colorsRemainingCurrentIteration = MAX_COLORS\n        this._favoriteColorFound = false\n        this._nextIterationColors = []\n\n        this._initColors()\n    }\n\n    private _initColors() {\n        this._colors = [0, 1] as [color, color]\n\n        for (let i = 2; i < 0x1000000; i++) {\n            this._colors.push(i as color)\n        }\n\n        shuffle(this._colors)\n    }\n\n    private _updateSelectedColors(num: 1 | 2): void {\n        const _do = (action: 'select' | 'eliminate', color: color): void => {\n            const [index, bit] = this._split(color)\n            const array =\n                action === 'select' ? 'selectedColors' : 'eliminatedColors'\n\n            assertColor(color)\n            if (action === 'select') {\n                this._nextIterationColors.push(this._colors.pop()!)\n            } else {\n                this._colors.pop()\n            }\n            this[array][index] |= bit\n        }\n\n        const selectAndEliminateColors = (select: color, elim: color): void => {\n            _do('select', select)\n            _do('eliminate', elim)\n        }\n\n        const selectedColor = num === 1 ? this.color1 : this.color2\n        const rejectedColor = num === 1 ? this.color2 : this.color1\n\n        selectAndEliminateColors(selectedColor, rejectedColor)\n    }\n\n    private _split(color: color): [index, bit] {\n        const [index, bit] = [color >> 5, 2 ** (color & 31)]\n        assertIndex(index)\n        assertBit(bit)\n        return [index, bit]\n    }\n\n    private _checkForNewIteration() {\n        if (this.colorsRemainingCurrentIteration !== 0) {\n            return\n        }\n\n        this._colorsRemainingCurrentIteration =\n            MAX_COLORS / 2 ** this.currentIteration\n        this._currentIteration++\n        this.selectedColors = new Uint32Array(0x80000)\n\n        if (this._nextIterationColors.length < 1) {\n            throw new Error('Array is empty but should not be')\n        }\n\n        this._colors = shuffle(this._nextIterationColors) as colorsAry\n        this._nextIterationColors = []\n    }\n\n    private _checkForFavoriteColor() {\n        this._favoriteColorFound = this.colorsRemainingCurrentIteration === 1\n    }\n\n    private _is(color: color, testingFor: 'eliminated' | 'selected'): boolean {\n        const [index, bit] = this._split(color)\n\n        const num =\n            testingFor === 'eliminated'\n                ? this.eliminatedColors[index]\n                : this.selectedColors[index]\n\n        if (num === undefined) {\n            return false\n        }\n\n        return !!(num & bit)\n    }\n}\n", "import {\n    Game,\n    _split,\n    color,\n    createGame,\n    isEliminated,\n    isSelected,\n    selectColor,\n} from 'scripts/game'\n\nimport { _Game } from 'scripts/_game'\n\n//import * as fs from 'fs'\nimport * as fsPromises from 'fs/promises'\n\nconst MAX_COLORS = 0x1000000\n\nfunction assertTrue(val: any): asserts val is true {\n    if (!val) {\n        throw new Error('val is not true')\n    }\n}\n\nfunction loop(g: _Game, numLoops: number) {\n    for (let i = 0; i < numLoops; i++) {\n        g.selectColor(1)\n    }\n}\n\nfunction testSelectColor() {\n    const g = new _Game()\n    let selected: color = g.color1\n    let eliminated: color = g.color2\n    g.selectColor(1)\n\n    assertTrue(g.isEliminated(eliminated))\n    assertTrue(g.isSelected(selected))\n\n    // now do it a bunch more times\n    for (let i = 0; i < 0xffff; i++) {\n        selected = g.color1\n        eliminated = g.color2\n        g.selectColor(1)\n        //console.log(i)\n        assertTrue(g.isEliminated(eliminated))\n        assertTrue(g.isSelected(selected))\n    }\n\n    console.log('testSelectColor PASS')\n}\n\nfunction testUintArray() {\n    const ary = new Uint32Array(0x80000)\n\n    for (let i = 0; i < MAX_COLORS; i++) {\n        const [index, bit] = _split(i as color)\n\n        const num = ary[index]\n\n        if (num === undefined) {\n            console.log('num is not truthy: ', num)\n            continue\n        }\n\n        assertTrue(!(num & bit))\n        ary[index] |= bit\n    }\n    console.log('testUintArray PASS')\n}\n\nasync function testColorUniqueness() {\n    async function _assertTrue(val: any) {\n        if (!val) {\n            const elimFh = await fsPromises.open('elim.txt', 'w')\n            const seleFh = await fsPromises.open('sele.txt', 'w')\n            const coloFh = await fsPromises.open('colo.txt', 'w')\n\n            for (let num of g.eliminatedColors) {\n                await elimFh.write(num.toString() + '\\n')\n            }\n\n            for (let num of g.selectedColors) {\n                await seleFh.write(num.toString() + '\\n')\n            }\n\n            for (let num of colors) {\n                await coloFh.write(num.toString() + '\\n')\n            }\n\n            await elimFh.close()\n            await seleFh.close()\n            await coloFh.close()\n\n            throw new Error('val is not true')\n        }\n    }\n\n    const g = new _Game()\n    const colors = new Set<color>()\n\n    for (let i = 0; i < MAX_COLORS / 2; i++) {\n        await _assertTrue(!colors.has(g.color1))\n        await _assertTrue(!colors.has(g.color2))\n\n        colors.add(g.color1)\n        colors.add(g.color2)\n\n        g.selectColor(1)\n    }\n\n    console.log('testColorUniqueness PASS')\n}\n\nfunction testCheckForNewIteration() {\n    const g = new _Game()\n    let curColors: number = g.colorsRemainingCurrentIteration\n    let curIter: number = g.currentIteration\n\n    function _assertTrue(val: any) {\n        if (!val) {\n            console.log(g)\n            console.log('curIter: ', curIter)\n            console.log('curColors: ', curColors)\n\n            assertTrue(val)\n        }\n    }\n\n    function assertVals() {\n        _assertTrue(g.currentIteration === curIter)\n        _assertTrue(g.colorsRemainingCurrentIteration === curColors)\n    }\n\n    function incrementVals() {\n        curColors = MAX_COLORS / 2 ** curIter\n        curIter++\n    }\n\n    while (curColors !== 2) {\n        loop(g, MAX_COLORS / 2 ** curIter - 1)\n        _assertTrue(g.currentIteration === curIter)\n        g.selectColor(1)\n        incrementVals()\n        assertVals()\n    }\n\n    _assertTrue(!g.favoriteColor)\n\n    const c1 = g.color1\n\n    g.selectColor(2)\n    _assertTrue(g.favoriteColor || g.favoriteColor === 0)\n    _assertTrue(g.favoriteColor === c1)\n    console.log(g)\n    console.log('testCheckForNewIteration PASS')\n}\n\nfunction test_split() {\n    for (let i = 0; i < 1000; i++) {\n        const color = Math.floor(Math.random() * 0x1000000) as color\n\n        const [index, bit] = _split(color)\n\n        const cStr = color.toString(2)\n        const iStr = index.toString(2)\n        const bStr = bit.toString(2)\n\n        console.log(`color: ${cStr}`)\n        console.log(`[${iStr}] [${bStr}]`)\n    }\n}\n\nexport async function gameTests() {\n    testSelectColor()\n    testUintArray()\n    await testColorUniqueness()\n    testCheckForNewIteration()\n    //test_split()\n}\n", "import { gameTests } from './game.test'\nimport { testPerformance } from './performance.test'\n//testPerformance()\ngameTests()\n\n// 4753427\n"],
  "mappings": "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",
  "names": ["color", "assertIndex", "assertBit", "color", "MAX_COLORS"]
}
