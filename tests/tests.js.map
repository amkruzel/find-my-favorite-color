{
  "version": 3,
  "sources": ["tests.ts", "../scripts/condensedColors.ts", "../scripts/game.ts", "../scripts/utils/utils.ts", "../scripts/colors.ts", "colors.test.ts", "condensedColors.test.ts"],
  "sourcesContent": ["//import { testDb } from './db.test'\n//import { gameTests } from './game.test'\n//import { testPerformance } from './performance.test'\n//import { testColors } from './colors.test'\nimport { describe } from 'node:test'\nimport { colorTests } from './colors.test'\nimport { condensedColorTests } from './condensedColors.test'\nimport { dbTests } from './db.test'\nimport { gameTests } from './game.test'\n//testPerformance()\n//gameTests()\n\ndescribe('Classes', () => {\n    colorTests()\n    //condensedColorTests()\n    //gameTests()\n    //dbTests()\n})\n\n// 4753427\n", "import type { color } from './colors'\n\ntype index = number & { __type: index }\ntype bit = number & { __type: bit }\n\n/**\n * This class represents a Uint32Array of length 0x80000\n * each bit in each 32 bit number can be used as a flag,\n * such as checking if a color is eliminated or not\n */\nexport class CondensedColors {\n    protected ary: Uint32Array\n\n    constructor(vals?: ArrayBuffer) {\n        this.init(vals)\n    }\n\n    get blob(): Blob {\n        return new Blob([this.ary])\n    }\n\n    has(val: color): boolean {\n        const [index, bit] = this.split(val)\n        const num = this.get(index)\n        return !!(num & bit)\n    }\n\n    add(val: color): void {\n        const [index, bit] = this.split(val)\n        this.ary[index] |= bit\n    }\n\n    reset(): void {\n        this.init()\n    }\n\n    private split(val: color): [index, bit] {\n        const [index, bit] = [val >> 5, 2 ** (val & 31)]\n        assertIndex(index)\n        assertBit(bit)\n        return [index, bit]\n    }\n\n    private get(val: index): number {\n        const num = this.ary[val]\n\n        if (num === undefined) {\n            throw new Error(\n                `Value is undefined but should not be - val: '${val}'`\n            )\n        }\n\n        return num\n    }\n\n    private init(vals?: ArrayBuffer) {\n        if (vals) {\n            console.log(`AB bl: ${vals.byteLength}`)\n            console.log(`bl / 32: ${vals.byteLength / 32}`)\n\n            this.ary = new Uint32Array(vals, 0, 0x80000)\n        } else {\n            this.ary = new Uint32Array(0x80000)\n        }\n    }\n}\n\nfunction assertIndex(value: number): asserts value is index {\n    if (parseInt(`${value}`) !== value || value < 0 || value >= 0x80000) {\n        throw new Error('Not an index!')\n    }\n}\n\nfunction assertBit(value: number): asserts value is bit {\n    if (parseInt(`${value}`) !== value || value < 0 || value & (value - 1)) {\n        throw new Error('Not a bit!')\n    }\n}\n", "import { CondensedColors } from './condensedColors'\nimport { Colors, ColorsLoadData, color } from './colors'\n\nexport interface GameProps {\n    favoriteColorFound: boolean\n    currentIteration: number\n    colorsRemainingCurrentIteration: number\n}\n\nexport interface GameLoadArys {\n    eliminated: ArrayBuffer\n    selected: ArrayBuffer\n    colors: ArrayBuffer\n}\n\nexport class Game {\n    static MAX_COLORS = 0x1000000\n\n    eliminatedColors: CondensedColors\n    selectedColors: CondensedColors\n    private _favoriteColorFound: boolean\n    private _currentIteration: number\n    private _colorsRemainingCurrentIteration: number\n    _colors: Colors\n\n    id?: string\n\n    constructor(arys?: GameLoadArys, props?: GameProps) {\n        if (!arys || !props) {\n            this._init()\n        } else {\n            this._load(arys, props)\n        }\n    }\n\n    get color1() {\n        return this._colors.color1\n    }\n\n    get color2() {\n        return this._colors.color2\n    }\n\n    get currentIteration() {\n        return this._currentIteration\n    }\n\n    get colorsRemainingCurrentIteration() {\n        return this._colorsRemainingCurrentIteration\n    }\n\n    get favoriteColor() {\n        return this._favoriteColorFound ? this.color1 : null\n    }\n\n    get properties(): GameProps {\n        return {\n            favoriteColorFound: this.favoriteColor !== null,\n            currentIteration: this.currentIteration,\n            colorsRemainingCurrentIteration:\n                this.colorsRemainingCurrentIteration,\n        }\n    }\n\n    get next1000Colors(): Uint32Array {\n        return this._colors.next1000Colors\n    }\n\n    selectColor(num: 1 | 2) {\n        this._select(num)\n        this._colorsRemainingCurrentIteration -= 2\n        this._checkForNewIteration()\n        this._checkForFavoriteColor()\n    }\n\n    reset() {\n        this._init()\n    }\n\n    shuffleColors() {\n        this._colors.shuffle()\n    }\n\n    isEliminated(color: color) {\n        return this.eliminatedColors.has(color)\n    }\n\n    isSelected(color: color) {\n        return this.selectedColors.has(color)\n    }\n\n    protected _init() {\n        this.eliminatedColors = new CondensedColors()\n        this.selectedColors = new CondensedColors()\n        this._currentIteration = 1\n        this._colorsRemainingCurrentIteration = Game.MAX_COLORS\n        this._favoriteColorFound = false\n\n        this._buildColors()\n    }\n\n    private _load(arys: GameLoadArys, props: GameProps) {\n        this.eliminatedColors = new CondensedColors(arys.eliminated)\n        this.selectedColors = new CondensedColors(arys.selected)\n        this._currentIteration = props.currentIteration\n        this._colorsRemainingCurrentIteration =\n            props.colorsRemainingCurrentIteration\n        this._favoriteColorFound = props.favoriteColorFound\n\n        const data: ColorsLoadData = {\n            next1000: arys.colors,\n            eliminated: arys.eliminated,\n            selected: arys.selected,\n        }\n\n        this._buildColors(data)\n    }\n\n    /**\n     * The primary purpose of this method is to allow for easier testing.\n     * This method is overridded in the test class so that a worker thread is\n     * not used.\n     */\n    protected _buildColors(data?: ColorsLoadData) {\n        this._colors = new Colors(data)\n    }\n\n    private _select(num: 1 | 2): void {\n        const [selected, rejected] = this._colors.select(num)\n        this.selectedColors.add(selected)\n        this.eliminatedColors.add(rejected)\n    }\n\n    private _checkForNewIteration() {\n        if (this.colorsRemainingCurrentIteration !== 0) {\n            return\n        }\n\n        this._colorsRemainingCurrentIteration =\n            Game.MAX_COLORS / 2 ** this.currentIteration\n        this._currentIteration++\n        this.selectedColors.reset()\n    }\n\n    private _checkForFavoriteColor() {\n        this._favoriteColorFound = this.colorsRemainingCurrentIteration === 1\n    }\n}\n", "// https://stackoverflow.com/questions/2450954/how-to-randomize-shuffle-a-javascript-array\nexport function shuffle<T>(array: T[]): T[] {\n    let currentIndex = array.length\n\n    // While there remain elements to shuffle...\n    while (currentIndex != 0) {\n        // Pick a remaining element...\n        let randomIndex = Math.floor(Math.random() * currentIndex)\n        currentIndex--\n\n        // And swap it with the current element.\n        ;[array[currentIndex], array[randomIndex]] = [\n            array[randomIndex],\n            array[currentIndex],\n        ] as [T, T]\n    }\n\n    return array\n}\n", "import { Game } from './game'\nimport { shuffle } from './utils/utils'\n\nexport type color = number & { __type: color }\nexport type colorsAry = [color, color, ...color[]]\n\nexport interface ColorsLoadData {\n    next1000: ArrayBuffer\n    eliminated: ArrayBuffer\n    selected: ArrayBuffer\n}\n\nclass ColorsAry {\n    static new(): colorsAry {\n        return new Array() as colorsAry\n    }\n\n    static from(ary: ArrayBuffer): colorsAry {\n        const tmp = Array.from(new Uint32Array(ary))\n        assertColorsAry(tmp)\n        return tmp\n    }\n}\n\nexport class Colors {\n    protected selectedColors: color[]\n    protected ary: colorsAry\n    protected favoriteColorFound: boolean\n    private static bgKey: number\n\n    constructor(data?: ColorsLoadData) {\n        this.init(data)\n    }\n\n    private init(data?: ColorsLoadData) {\n        this.ary = ColorsAry.new()\n        this.selectedColors = Array()\n        this.favoriteColorFound = false\n\n        if (data) {\n            this.ary = ColorsAry.from(data.next1000)\n        } else {\n            this.first1000()\n        }\n\n        this.bg(data)\n    }\n\n    private first1000() {\n        for (let i = 0; i < 1000; i++) {\n            let color: number\n\n            do {\n                // ~~ is identical to Math.floor() but is faster\n                color = ~~(Math.random() * Game.MAX_COLORS)\n                assertColor(color)\n            } while (this.ary.includes(color))\n\n            this.ary.push(color)\n        }\n        assertColorsAry(this.ary)\n    }\n\n    protected bg(\n        data: { eliminated: ArrayBuffer; selected: ArrayBuffer } | null = null\n    ) {\n        const worker = new Worker('workers/colors.js')\n        worker.postMessage([[this.ary, data], this.reloadBgKey])\n\n        worker.onmessage = msg => {\n            const [[colors, selectedColors], oldKey] = msg.data\n\n            if (this.isInvalid(oldKey)) {\n                return\n            }\n\n            assertColorsAry(colors)\n            this.ary.splice(0, 0, ...colors)\n\n            if (selectedColors?.length !== 0) {\n                this.selectedColors.splice(0, 0, ...selectedColors)\n            }\n        }\n    }\n\n    protected isInvalid(key: any) {\n        return typeof key !== 'number' || key !== Colors.bgKey\n    }\n\n    get color1(): color {\n        return this.getAndValidate(1)\n    }\n\n    get color2(): color {\n        return this.getAndValidate(2)\n    }\n\n    private getAndValidate(num: 1 | 2): color {\n        const c = this.ary[this.ary.length - num]\n        assertDefined(c)\n        return c\n    }\n\n    get next1000Colors(): Uint32Array {\n        return Uint32Array.from(this.ary.slice(0, 1000))\n    }\n\n    shuffle() {\n        const c1 = this.ary.shift()\n        const c2 = this.ary.shift()\n\n        assertDefined(c1)\n        assertDefined(c2)\n\n        this.ary.push(c1, c2)\n    }\n\n    /**\n     * Updates ary, ensuring that there are always >= 2 elements.\n     * If this.ary.length == 2 at the beginning of the method, then both elements\n     * will be the same at the end - the selected color.\n     * @return the colors in the format `[selected, rejected]`\n     */\n    select(num: 1 | 2): [color, color] {\n        const selectedColor = num === 1 ? this.color1 : this.color2\n        const rejectedColor = num === 1 ? this.color2 : this.color1\n\n        if (this.favoriteColorFound) {\n            return [selectedColor, rejectedColor]\n        }\n\n        this.selectedColors.push(selectedColor)\n\n        const moreThan2ColorsRemaining = this.ary.length > 2\n\n        if (moreThan2ColorsRemaining) {\n            this.pop2()\n        } else {\n            this.resetAry()\n        }\n\n        return [selectedColor, rejectedColor]\n    }\n\n    private pop2() {\n        this.ary.splice(this.ary.length - 2, 2)\n    }\n\n    protected resetAry() {\n        this.validateAry()\n\n        this.favoriteColorFound = this.selectedColors.length === 1\n\n        if (this.favoriteColorFound) {\n            this.selectedColors.push(this.selectedColors[0]!) // must be defined because we just pushed a value\n        }\n\n        this.reset()\n    }\n\n    private validateAry(): void {\n        if (this.ary.length !== 2) {\n            throw new Error('Array is the incorrect length')\n        }\n    }\n\n    /**\n     * Shuffles `this.selectedColors`, asserts that is is a `colorsAry`,\n     * sets `this.ary = <the shuffled ary>`, and clears `this.selectedColors`\n     */\n    private reset() {\n        const newAry = shuffle(this.selectedColors)\n        assertColorsAry(newAry)\n        this.ary = newAry\n        this.selectedColors = []\n    }\n\n    protected get reloadBgKey(): number {\n        Colors.bgKey = Date.now()\n        return Colors.bgKey\n    }\n}\n\nexport function assertColor(value: number): asserts value is color {\n    if (parseInt(`${value}`) !== value || value < 0 || value > 0xffffff) {\n        throw new Error(value + 'is not a color!')\n    }\n}\n\nexport function assertColorsAry(ary: number[]): asserts ary is colorsAry {\n    if (\n        !ary.every(elem => {\n            assertColor(elem)\n            return true\n        }) ||\n        ary.length < 2\n    ) {\n        console.log(ary)\n        throw new Error('Not a colorsAry!')\n    }\n}\n\nfunction assertDefined(val: color | undefined): asserts val is color {\n    if (val === undefined) {\n        throw new Error('Value is undefined!')\n    }\n}\n", "import {\n    Colors,\n    ColorsLoadData,\n    assertColor,\n    assertColorsAry,\n} from 'scripts/colors'\nimport { color, colorsAry } from 'scripts/colors'\nimport { Game } from 'scripts/game'\nimport { shuffle } from 'scripts/utils/utils'\n\nimport { describe, it } from 'node:test'\nimport assert from 'node:assert'\nimport { TestCondensedColors } from './condensedColors.test'\n\nimport { Worker } from 'node:worker_threads'\n\nexport class TestColors extends Colors {\n    isBgWorkDone: boolean\n\n    constructor(data?: ColorsLoadData) {\n        super(data)\n    }\n\n    get raw() {\n        return this.ary\n    }\n\n    get nextIter(): color[] {\n        return this.selectedColors\n    }\n\n    get faveColorFound() {\n        return this.favoriteColorFound\n    }\n\n    protected override bg(\n        data: { eliminated: ArrayBuffer; selected: ArrayBuffer } | null = null\n    ) {\n        const worker = new Worker('workers/colors.js')\n        worker.postMessage([[this.ary, data], this.reloadBgKey])\n\n        worker.on('message', msg => {\n            const [[colors, selectedColors], oldKey] = msg.data\n\n            if (this.isInvalid(oldKey)) {\n                return\n            }\n\n            assertColorsAry(colors)\n            this.ary.splice(0, 0, ...colors)\n\n            if (selectedColors?.length !== 0) {\n                this.selectedColors.splice(0, 0, ...selectedColors)\n            }\n        })\n    }\n\n    protected _bg(\n        data: { eliminated: ArrayBuffer; selected: ArrayBuffer } | null = null\n    ) {\n        if (!data) {\n            const shuffledColors = fullShuffledArray(this.ary)\n            assertColorsAry(shuffledColors)\n            this.buildIncrementally(shuffledColors, [])\n            this.isBgWorkDone = true\n            return\n        }\n\n        const eliminatedColors = new TestCondensedColors(data.eliminated)\n        const selectedColors = new TestCondensedColors(data.selected)\n\n        const [colorsToAdd, nextIterColors] = doWork(this.ary, {\n            eliminated: eliminatedColors,\n            selected: selectedColors,\n        })\n\n        this.buildIncrementally(colorsToAdd, nextIterColors)\n\n        this.isBgWorkDone = true\n    }\n\n    private buildIncrementally(colors: color[], nextIterColors: color[]): void {\n        const HUNDRED_THOU = 100000\n        for (let i = 0; i < 170; i++) {\n            const min = i * HUNDRED_THOU\n            const max = min + HUNDRED_THOU\n\n            if (min >= Game.MAX_COLORS) {\n                break\n            }\n\n            const colorsSubset = colors.slice(min, max)\n            const nextIterSubset = nextIterColors.slice(min, max)\n\n            if (colorsSubset.length == 0) {\n                console.log(min)\n                console.log(max)\n            }\n\n            assertColorsAry(colorsSubset)\n\n            this.ary.splice(0, 0, ...colorsSubset)\n\n            if (nextIterSubset?.length !== 0) {\n                this.selectedColors.splice(0, 0, ...nextIterSubset)\n            }\n        }\n    }\n}\n\nfunction fullShuffledArray(origColors: number[]): number[] {\n    const colors: number[] = []\n    for (let i = 0; i < Game.MAX_COLORS; i++) {\n        if (origColors.includes(i)) {\n            continue\n        }\n        colors.push(i)\n    }\n\n    return shuffle(colors)\n}\n\nfunction doWork(\n    colors: colorsAry,\n    arrays: {\n        eliminated: TestCondensedColors\n        selected: TestCondensedColors\n    }\n): [color[], color[]] {\n    // go through all numbers\n    // - if a number is included in colors, skip it\n    // - if a number is included in eliminatedColors, skip it\n    // - if a color is included in selectedColors, add it to nextIterColors\n    const newColors = []\n    const nextIterColors = []\n\n    for (let color = 0; color < Game.MAX_COLORS; color++) {\n        assertColor(color)\n        const isEliminated = arrays.eliminated.has(color)\n        const isSelected = arrays.selected.has(color)\n        const alreadyIncluded = colors.includes(color)\n\n        if (isSelected) {\n            nextIterColors.push(color)\n            continue\n        }\n\n        if (isEliminated || alreadyIncluded) {\n            continue\n        }\n\n        newColors.push(color)\n    }\n\n    return [shuffle(newColors), shuffle(nextIterColors)]\n}\n\nexport const colorTests = () => {\n    describe('Colors', () => {\n        const c = new TestColors()\n\n        it('should initialize', () => {\n            assert.equal(true, c.isBgWorkDone)\n        })\n\n        it('should get new colors after a selection', () => {\n            const [c1, c2] = [c.color1, c.color2]\n\n            c.select(1)\n\n            assert.notEqual(c1, c.color1)\n            assert.notEqual(c2, c.color2)\n        })\n\n        it('should correctly select colors', () => {\n            const numSelections = c.raw.length / 2\n\n            for (let i = 0; i < numSelections - 1; i++) {\n                c.select(1)\n            }\n\n            assert.equal(c.raw.length, 2)\n        })\n\n        it('should currectly shuffle when there are only two colors', () => {\n            const [c1, c2] = [c.color1, c.color2].sort()\n\n            c.shuffle()\n\n            const [newC1, newC2] = [c.color1, c.color2].sort()\n\n            assert.equal(c1, newC1)\n            assert.equal(c2, newC2)\n        })\n\n        it('should rebuild the array once all colors have been selected', () => {\n            c.select(2)\n\n            assert.equal(c.raw.length, Game.MAX_COLORS / 2)\n        })\n\n        it('should correctly iterate through the entire game', () => {\n            while (!c.faveColorFound) {\n                c.select(1)\n            }\n        })\n\n        it('should correctly load colors', async () => {\n            const c2 = new TestColors()\n            const elim = new TestCondensedColors()\n            const select = new TestCondensedColors()\n\n            for (let i = 0; i < 100000; i++) {\n                elim.add(c2.color2)\n                select.add(c2.color1)\n                c2.select(1)\n            }\n\n            console.log(c2.next1000Colors.length)\n\n            const next1000b = new Blob([c2.next1000Colors])\n            const next1000 = await next1000b.arrayBuffer()\n            const eliminated = await elim.blob.arrayBuffer()\n            const selected = await select.blob.arrayBuffer()\n\n            const newC = new TestColors({ next1000, eliminated, selected })\n\n            assert.equal(c2.color1, newC.color1)\n            assert.equal(c2.color2, newC.color2)\n        })\n    })\n}\n", "import assert from 'node:assert'\nimport { describe, it } from 'node:test'\nimport { assertColor } from 'scripts/colors'\nimport { CondensedColors } from 'scripts/condensedColors'\nimport { Game } from 'scripts/game'\n\nexport class TestCondensedColors extends CondensedColors {\n    constructor(vals?: ArrayBuffer) {\n        super(vals)\n    }\n\n    get raw(): Uint32Array {\n        return this.ary\n    }\n}\n\nexport const condensedColorTests = () => {\n    const c = new TestCondensedColors()\n\n    function randomInt() {\n        return ~~(Math.random() * Game.MAX_COLORS)\n    }\n\n    describe('CondensedColors', () => {\n        it('correctly inserts colors', () => {\n            for (let i = 0; i < 10; i++) {\n                const int = randomInt()\n\n                assertColor(int)\n\n                if (!c.has(int)) {\n                    c.add(int)\n                }\n\n                assert.equal(c.has(int), true)\n            }\n        })\n\n        it('returns a blob that can be converted back to CondensedColors', async () => {\n            const b = c.blob\n\n            const newC = new TestCondensedColors(await b.arrayBuffer())\n            const newB = newC.blob\n\n            // A) Convert files to ArrayBuffer:\n            const arrayBufferFileA = await b.arrayBuffer()\n            const arrayBufferFileB = await newB.arrayBuffer()\n\n            // Stop if the files are not the same size:\n            assert.equal(\n                arrayBufferFileA.byteLength,\n                arrayBufferFileB.byteLength\n            )\n\n            // B) Convert ArrayBuffer to Uint8Array for byte-size comparison:\n            const uint8ArrayA = new Uint8Array(arrayBufferFileA)\n            const uint8ArrayB = new Uint8Array(arrayBufferFileB)\n\n            for (let i = 0, len = uint8ArrayA.length; i < len; i++) {\n                assert.equal(uint8ArrayA[i], uint8ArrayB[i])\n            }\n        })\n\n        it('loads from ArrayBuffer correctly', async () => {\n            const x = await c.blob.arrayBuffer()\n\n            const newC = new TestCondensedColors(x)\n\n            for (let i = 0; i < Game.MAX_COLORS; i++) {\n                assertColor(i)\n                assert.equal(c.has(i), newC.has(i))\n            }\n        })\n    })\n}\n"],
  "mappings": "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",
  "names": ["import_node_test", "color", "color", "import_node_test", "color", "assert"]
}
